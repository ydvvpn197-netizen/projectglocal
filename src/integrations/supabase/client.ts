// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { config } from '@/config/environment';
import { retryWithBackoff, waitForOnline } from '@/utils/networkUtils';

// Use environment configuration with fallbacks
const SUPABASE_URL = config.supabase.url;
const SUPABASE_PUBLISHABLE_KEY = config.supabase.anonKey;

// Validate Supabase configuration
if (!SUPABASE_URL || !SUPABASE_PUBLISHABLE_KEY) {
  console.error('Supabase configuration is missing. Please check your environment variables.');
  throw new Error('Supabase configuration is required');
}

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    storage: localStorage,
    persistSession: true,
    autoRefreshToken: true,
    detectSessionInUrl: true,
  },
  global: {
    headers: {
      'X-Client-Info': 'theglocal-web'
    }
  },
  realtime: {
    params: {
      eventsPerSecond: 10
    },
    heartbeatIntervalMs: 30000,
    reconnectAfterMs: (tries) => Math.min(tries * 1000, 10000)
  }
});

// Add error handling for network issues
supabase.auth.onAuthStateChange((event, session) => {
  if (event === 'TOKEN_REFRESHED') {
    console.log('Token refreshed successfully');
  } else if (event === 'SIGNED_OUT') {
    console.log('User signed out');
  }
});

// Handle network errors
window.addEventListener('online', () => {
  console.log('Network connection restored');
});

window.addEventListener('offline', () => {
  console.log('Network connection lost');
});

// Create a resilient wrapper for Supabase operations
export const resilientSupabase = {
  auth: {
    ...supabase.auth,
    getSession: async () => {
      return retryWithBackoff(async () => {
        return await supabase.auth.getSession();
      }, { maxRetries: 2, delay: 1000 });
    },
    signInWithPassword: async (credentials: { email: string; password: string }) => {
      return retryWithBackoff(async () => {
        return await supabase.auth.signInWithPassword(credentials);
      }, { maxRetries: 2, delay: 1000 });
    },
    signUp: async (credentials: any) => {
      return retryWithBackoff(async () => {
        return await supabase.auth.signUp(credentials);
      }, { maxRetries: 2, delay: 1000 });
    },
    signOut: async () => {
      return retryWithBackoff(async () => {
        return await supabase.auth.signOut();
      }, { maxRetries: 2, delay: 1000 });
    }
  },
  from: (table: string) => {
    const query = supabase.from(table);
    return {
      ...query,
      select: (...args: any[]) => {
        return retryWithBackoff(async () => {
          return await query.select(...args);
        }, { maxRetries: 2, delay: 1000 });
      },
      insert: (...args: any[]) => {
        return retryWithBackoff(async () => {
          return await query.insert(...args);
        }, { maxRetries: 2, delay: 1000 });
      },
      update: (...args: any[]) => {
        return retryWithBackoff(async () => {
          return await query.update(...args);
        }, { maxRetries: 2, delay: 1000 });
      },
      delete: (...args: any[]) => {
        return retryWithBackoff(async () => {
          return await query.delete(...args);
        }, { maxRetries: 2, delay: 1000 });
      }
    };
  },
  rpc: (func: string, params?: any) => {
    return retryWithBackoff(async () => {
      return await supabase.rpc(func, params);
    }, { maxRetries: 2, delay: 1000 });
  }
};